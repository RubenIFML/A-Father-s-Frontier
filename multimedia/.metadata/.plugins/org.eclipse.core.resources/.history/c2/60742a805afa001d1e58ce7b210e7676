package ow_elements;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;

import game.Parametros;
import managers.ResourceManager;
import screens.OverWorldScreen;

public class Protagonista extends Element {
    private boolean unaVez = false;
    private float deadzoneRadius = 12; // Radio de la zona muerta
    public Sound pasos;
    private Animation<TextureRegion> animacionLoca;
    private boolean animacionLocaOn;
    private float tiempoAnimacion;

    public Protagonista(float x, float y, Stage s, OverWorldScreen nivel) {
        super(x, y, s);
        pasos = ResourceManager.getSound("02-OW/Audio/sounds/pasos.wav");

        prepararAnimacion("02-OW/Personajes/personaje.protagonista_ow.png", true);
        animacionLoca = loadFullAnimation("02-OW/Personajes/personaje.protagonista.final_ow.png", 1, 9, 0.2f, false);

        setAnimation(idleFrente);
        this.setPolygon(8, 32, 23, 5, 5);
        tiempoAnimacion = 0;
    }

    @Override
    public void act(float delta) {
        if (animacionLocaOn) {
            tiempoAnimacion += delta;
            Animation<TextureRegion> frameAnimation = new Animation<TextureRegion>(0.2f, animacionLoca.getKeyFrames());
            TextureRegion frame = frameAnimation.getKeyFrame(tiempoAnimacion, false);
            this.setAnimation(frame);
        } else {
            if (Parametros.controlesActivos) {
                super.act(delta);
                if (Gdx.input.isButtonPressed(Input.Buttons.RIGHT)) {
                    Vector2 clickPos = getStage().screenToStageCoordinates(new Vector2(Gdx.input.getX(), Gdx.input.getY()));
                    Vector2 direction = new Vector2(clickPos).sub(getX() + 20, getY() + 8);

                    // Si el cursor está dentro de la zona muerta, no cambiamos de dirección
                    if (direction.len() > deadzoneRadius) {
                        direction.nor();
                        this.velocity.set(direction.scl(130));

                        if (unaVez) {
                            pasos.play();
                            pasos.loop();
                            unaVez = false;
                        }
                    }
                } else {
                    pasos.stop();
                    this.velocity.y = 0;
                    this.velocity.x = 0;
                    unaVez = true;
                }
                animaciones();
                this.applyPhysics(delta);
            }
        }
    }

    private void animaciones() {
        if (this.velocity.isZero()) {
            Vector2 clickPos = getStage().screenToStageCoordinates(new Vector2(Gdx.input.getX(), Gdx.input.getY()));
            Vector2 direction = new Vector2(clickPos).sub(getX(), getY());
            Vector2 up = new Vector2(0, 1);
            float angleRad = direction.angleRad(up);

            if (angleRad < -MathUtils.PI / 4f && angleRad > -3f * MathUtils.PI / 4f) {
                this.setAnimation(idleIzquierda);
            } else if (angleRad > MathUtils.PI / 4f && angleRad < 3f * MathUtils.PI / 4f) {
                this.setAnimation(idleDerecha);
            } else if (angleRad > 3f * MathUtils.PI / 4f || angleRad < -3f * MathUtils.PI / 4f) {
                this.setAnimation(espalda);
            } else {
                this.setAnimation(idleFrente);
            }
        } else {
            Vector2 up = new Vector2(0, 1);
            float angleRad = velocity.angleRad(up);

            if (angleRad < -MathUtils.PI / 4f && angleRad > -3f * MathUtils.PI / 4f) {
                this.setAnimation(izquierda);
            } else if (angleRad > MathUtils.PI / 4f && angleRad < 3f * MathUtils.PI / 4f) {
                this.setAnimation(derecha);
            } else if (angleRad > 3f * MathUtils.PI / 4f || angleRad < -3f * MathUtils.PI / 4f) {
                this.setAnimation(espalda);
            } else {
                this.setAnimation(frente);
            }
        }
    }

    public void animacionFinal() {
        if (!animacionLocaOn) {
            animacionLocaOn = true;
            tiempoAnimacion = 0;
        } else {
            animacionLocaOn = false;
            this.setAnimation(idleFrente);
        }
    }
}



